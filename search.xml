<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6-Promise</title>
      <link href="2021/01215804.html"/>
      <url>2021/01215804.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是Promise？</h2><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现,ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1、对象的状态不受外界影响（3种状态）</p><ul><li>Pending状态（进行中）</li><li>Fulfilled状态（已成功）</li><li>Rejected状态（已失败）</li></ul><p>2、一旦状态改变就不会再变（两种状态改变：成功或失败）</p><ul><li>Pending -&gt; Fulfilled</li><li>Pending -&gt; Rejected</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="创建Promise实例"><a href="#创建Promise实例" class="headerlink" title="创建Promise实例"></a>创建Promise实例</h3><pre class=" language-js"><code class="language-js"> <span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... some code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">/* 异步操作成功 */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> </code></pre><p>&emsp; Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p><p>&emsp; resolve作用是将Promise对象状态由“未完成”变为“成功”，也就是<code>Pending</code> -&gt; <code>Fulfilled</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；而reject函数则是将Promise对象状态由“未完成”变为“失败”，也就是<code>Pending -&gt; Rejected</code>，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。</p><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>&emsp; Promise实例生成后，可用<code>then</code>方法分别指定两种状态回调参数。<code>then</code>方法可以接受两个回调函数作为参数：</p><ol><li>Promise对象状态改为Resolved时调用（必选）</li><li>Promise对象状态改为Rejected时调用（可选）</li></ol><h3 id="基本用法示例"><a href="#基本用法示例" class="headerlink" title="基本用法示例"></a>基本用法示例</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"finished"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>&emsp;这段代码定义了一个函数sleep，调用后，等待了指定参数(500)毫秒后执行then中的函数。值得注意的是，Promise新建后就会立即执行。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>&emsp;接下来我们探究一下它的执行顺序。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"ccc"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// aaa</span><span class="token comment" spellcheck="true">// ccc</span><span class="token comment" spellcheck="true">// bbb</span></code></pre><p>&emsp;执行后，我们发现输出顺序总是 <code>aaa -&gt; ccc -&gt; bbb</code>。表明，在Promise新建后会立即执行，所以<strong>首先输出</strong> <code>aaa</code>。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行，所以<code>bbb</code> <strong>最后输出</strong>。</p><h3 id="与定时器混用"><a href="#与定时器混用" class="headerlink" title="与定时器混用"></a>与定时器混用</h3><p>&emsp; 首先看一个实例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1</span><span class="token comment" spellcheck="true">// 4</span><span class="token comment" spellcheck="true">// 3</span><span class="token comment" spellcheck="true">// 2</span></code></pre><p>&emsp; 可以看到，结果输入顺序是：<code>1 -&gt; 4 -&gt; 3 -&gt; 2</code>。 1与4的顺序不必再说，而2与3先输出Promise的then，然后输出定时器的结果。原因则是Promise属于JavaScript引擎内部任务，而setTimeout则是浏览器API，而引擎内部任务优先级高于浏览器API任务，所以有此结果。</p><h2 id="拓展async-await"><a href="#拓展async-await" class="headerlink" title="拓展async/await"></a>拓展async/await</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>&emsp; 异步。async函数对 Generator 函数的改进，async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。特点体现在以下四点：</p><ul><li>内置执行器</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是 Promise</li></ul><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>&emsp; 顾名思义，等待。正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。</p><h3 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h3><p>&emsp;先看示例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"BBB"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// AAA</span><span class="token comment" spellcheck="true">// BBB (5000ms后)</span></code></pre><p>&emsp;我们定义函数<code>sleep</code>，返回一个<code>Promise</code>。然后在<code>handle</code>函数前加上<code>async</code>关键词，这样就定义了一个<code>async</code>函数。在该函数中，利用<code>await</code>来等待一个<code>Promise</code>。</p><h2 id="Promise的优缺点"><a href="#Promise的优缺点" class="headerlink" title="Promise的优缺点"></a>Promise的优缺点</h2><p><strong>优点</strong></p><ul><li>解决回调</li><li>链式调用</li><li>减少嵌套</li><li>代码优雅</li></ul><p><strong>缺点</strong></p><ul><li>无法监测进行状态</li><li>新建立即执行且无法取消</li><li>内部错误无法抛出</li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的hexo-theme-matery主题搭建博客并优化</title>
      <link href="2020/123043699.html"/>
      <url>2020/123043699.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p><a href="https://hexo.io/zh-cn/index.html">Hexo</a> 是一个快速、简洁且高效的博客框架。对于有一定技术背景的同学，自己动手搭建博客网站是一个很不错的选择。选择喜欢的主题，按需进行个性化配置，随时用自己喜欢的工具写文章，一键发布到多个博客托管平台。作为程序员当然要有自己的博客，赶快动手为自己搭建一个吧！</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;安装Hexo也并不很难，只需要满足以下条件即可。</p><ul><li>Git</li><li>Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li></ul><p>当满足Git和Node.js这两个条件后，就可以进行安装了。</p><p><strong>在cmd命令面板输入这行命令：</strong> <code>npm install -g hexo-cli</code></p><p>安装完成后，在你想搭建博客的盘下新建一个文件夹，在此盘下命令行输入：<code>md blog</code> ——<em>注意：这里的blog是<strong>自定义</strong>的文件名</em>。当然，你也可以在此电脑中操作。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>接下来进入到我们刚才创建的文件夹内，在命令行输入 <code>cd blog</code>。创建完成后进blog目录下输入命令<code> hexo init</code> 这里作用是初始化博客目录。<br>接下来去文件夹看一下，此时的blog目录下应该多了很多东西。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在命令行输入：<code> hexo server</code> 或者 <code> hexo s</code>，接下来应该会返回一个端口链接： <code>http://localhost:4000</code> 。在浏览器输入就可以在本地启动你的博客站点了，怎么样，是不是很简单。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>什么？默认主题不好看？<br>其实，我也这么认为，那么，我们来换个主题吧！</p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>这里我们演示 <strong>hexo-theme-matery</strong> 主题，hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题，前往<a href="https://github.com/blinkfox/hexo-theme-matery">girhub</a>下载 master 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到 blog 的 <code>themes</code> 文件夹中即可。</p><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 blog 目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code>。</p><p><strong><code>_config.yml </code>文件的其它修改建议:</strong></p><ul><li>请修改 <code>_config.yml</code> 的 url 的值为你的网站主 URL（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="配置主题页面"><a href="#配置主题页面" class="headerlink" title="配置主题页面"></a>配置主题页面</h3><h4 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>categories/index.md </code>文件，那么就需要新建一个，命令如下：<br><code> hexo new page &quot;categories&quot;</code><br>或者你也可以去文件夹中直接创建，这样更简单明了。</p><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-md"><code class="language-md">---title: categoriesdate: 2020-12-30 17:25:30type: "categories"layout: "categories"---</code></pre><h4 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>tags/index.md </code>文件，那么就需要新建一个，命令如下：<br><code> hexo new page &quot;tags&quot;</code></p><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-md"><code class="language-md">---title: tagsdate: 2020-12-30 17:25:30type: "tags"layout: "tags"---</code></pre><h4 id="新建关于-about-页"><a href="#新建关于-about-页" class="headerlink" title="新建关于 about 页"></a>新建关于 about 页</h4><p><code>about</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>about/index.md </code>文件，那么就需要新建一个，命令如下：<br><code> hexo new page &quot;about&quot;</code></p><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-md"><code class="language-md">---title: aboutdate: 2020-12-30 17:25:30type: "about"layout: "about"---</code></pre><h4 id="新建友情链接-friends-页"><a href="#新建友情链接-friends-页" class="headerlink" title="新建友情链接 friends 页"></a>新建友情链接 friends 页</h4><p><code>friends</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>friends/index.md </code>文件，那么就需要新建一个，命令如下：<br><code> hexo new page &quot;friends&quot;</code></p><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-md"><code class="language-md">---title: friendsdate: 2020-12-30 17:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-md"><code class="language-md">[{    "avatar": "https://www.lixl.cn/medias/avatar.jpg",    "name": "LoM",    "introduction": "人生就是一场修行，上善若水，厚德载物。",    "url": "https://lom-11.github.io/",    "title": "前去参观"}, {    "avatar": "https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg",    "name": "Hexo",    "introduction": "快速、简洁且高效的博客框架",    "url": "https://hexo.io/zh-cn/",    "title": "前去学习"}, {    "avatar": "https://cn.vuejs.org/images/logo.png",    "name": "Vue",    "introduction": "渐进式JavaScript框架",    "url": "https://cn.vuejs.org/",    "title": "前去学习"}]</code></pre><h4 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h4><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h4 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h4><p>在主题的 <code>_config.yml</code> 文件中，默认支持 QQ、GitHub 和邮箱的配置，可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：fa-github）可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><h4 id="修改打赏二维码图片"><a href="#修改打赏二维码图片" class="headerlink" title="修改打赏二维码图片"></a>修改打赏二维码图片</h4><p>在主题文件的 <code>source/medias/reward</code> 文件中，可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：<br><code> npm i -S hexo-prism-plugin</code></p><p>然后，修改 <code>blog</code> 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>hexo-prism-plugin</code> 插件相关的配置，主要配置如下：<br>修改以下：</p><pre class=" language-md"><code class="language-md">highlight:  enable: false</code></pre><p>添加以下：</p><pre class=" language-md"><code class="language-md">prism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <code>hexo-generator-search</code> 的 Hexo 插件来做内容搜索，安装命令如下：<br><code>npm install hexo-generator-search --save</code></p><p>在 blog 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre class=" language-md"><code class="language-md">search:  path: search.xml  field: post</code></pre><h3 id="文章链接转静态短地址"><a href="#文章链接转静态短地址" class="headerlink" title="文章链接转静态短地址"></a>文章链接转静态短地址</h3><p>如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <code>hexo-permalink-pinyin Hexo</code> 插件生成文章时生成中文拼音的永久链接，或者用<code>hexo-abbrlink</code> 生成静态文章链接。以下结合<code>hexo-abbrlink</code>生成类似 <code>/yyyy/mmdd+随机数.html </code>的文章链接地址。</p><p>安装命令如下：<br><code> npm install hexo-abbrlink --save</code></p><p>在 <code>blog</code> 根目录下的 <code>_config.yml </code>文件中，修改 <code>permalink</code>: </p><pre class=" language-md"><code class="language-md">permalink: :year/:month:day:abbrlink.html</code></pre><p>并在文件末尾新增 <code>abbrlink:</code>配置项：</p><pre class=" language-md"><code class="language-md">abbrlink:   alg: crc16 #算法选项：crc16丨crc32  rep: dec #输出进制：dec为十进制，hex为十六进制</code></pre><h3 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：<br><code>npm i --save hexo-wordcount</code><br>然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可：</p><pre class=" language-md"><code class="language-md">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre><h3 id="添加-RSS-订阅支持-可选的"><a href="#添加-RSS-订阅支持-可选的" class="headerlink" title="添加 RSS 订阅支持(可选的)"></a>添加 RSS 订阅支持(可选的)</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 RSS，安装命令如下：<br><code>npm install hexo-generator-feed --save</code><br>在 blog 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-md"><code class="language-md">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明已经安装成功了。</p><h3 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h3><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><blockquote><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li><code>MathJax</code></li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li>不蒜子统计和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图。</li></ul></blockquote><p>如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能有用的地方：</p><h4 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h4><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>banner动态切换颜色遮罩层</p><pre class=" language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span></code></pre><h4 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h4><p>可以直接在 <code>/source/medias/banner</code> 文件夹中更换喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果会 JavaScript 代码，可以修改成自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>文章特色图：</strong><br>在 <code>/source/medias/featureimages</code> 文件夹中默认有 <code>24</code> 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h4 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h4><p><strong>Front-matter 选项详解</strong><br><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code>的文件标题</td><td align="left">文章标题</td></tr><tr><td align="left">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code> 中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code> 中的某个值</td><td align="left">文章特征图</td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">推荐文章（文章是否置顶），如果 top 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="left">cover</td><td align="left"><code>false</code></td><td align="left">表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="left">coverImg</td><td align="left">无</td><td align="left">表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 <code>_config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>_config.yml</code> 中激活了 toc 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><ul><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 <code>Front-matter</code> 中设置采用了 <code>SHA256</code> 加密的 <code>password</code> 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。</li></ul></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><p><strong>最简示例</strong></p><pre class=" language-md"><code class="language-md">---title: 基于Hexo的hexo-theme-matery主题搭建博客并优化date: 2020-12-30 14:30:00---</code></pre><p><strong>最全示例</strong> </p><pre class=" language-md"><code class="language-md">---title: 基于Hexo的hexo-theme-matery主题搭建博客date: 2020-12-30 14:30:00author: LoMimg: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: f3ca120c923ad8deeaf229280e6806e3f592a66d5a86969cad3cc30cafc6cf29toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: 博客框架tags:  - blog  - hexo---</code></pre><h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（<code>GitHub</code>不允许百度的<code>Spider</code>爬取<code>GitHub</code>上的内容）。</p><h2 id="部署Github"><a href="#部署Github" class="headerlink" title="部署Github"></a>部署Github</h2><p><strong><em>前提是建立好了git仓库~~</em></strong><br>博客搭建完成后，依次输入以下命令部署到github上：</p><blockquote><p><code>npm clean</code><br><code>npm generate</code><br><code>npm deploy</code></p></blockquote><p>然后就可以通过 <code>https://你的用户名.github.io </code> 来访问博客了。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p><code>hexo server</code> #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p></li><li><p><code>hexo server -s</code> #以静态模式启动</p></li><li><p><code>hexo server -p 5000</code> #更改访问端口 (默认端口为<code>4000</code>，’<code>ctrl + c</code>‘关闭<code>server</code>)</p></li><li><p><code>hexo server -i IP地址</code> #自定义 IP</p></li><li><p><code>hexo clean</code> #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p></li><li><p><code>hexo g</code> #生成静态网页 (执行 $ hexo g后会在站点根目录下生成 public 文件夹, hexo会将 “ /blog/source/ “ 下面- 的<code>.md</code>后缀的文件编译为<code>.html</code>后缀的文件,存放在 “ /blog/public/ “ 路径下)</p></li><li><p><code>hexo d</code> #自动生成网站静态文件，并将本地数据部署到设定的仓库(如<code>github</code>)</p></li><li><p><code>hexo init 文件夹名称</code> #初始化XX文件夹名称</p></li><li><p><code>npm update hexo -g</code> #升级</p></li><li><p><code>npm install hexo -g</code> #安装</p></li><li><p><code>node-v</code> #查看<code>node.js</code>版本号</p></li><li><p><code>npm -v</code> #查看<code>npm</code>版本号</p></li><li><p><code>git --version</code> #查看<code>git</code>版本号</p></li><li><p><code>hexo -v</code> #查看<code>hexo</code>版本号</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/122716107.html"/>
      <url>2020/122716107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
